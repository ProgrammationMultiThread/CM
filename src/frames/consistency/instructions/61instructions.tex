\mode*

\begin{frame}[fragile]{Registres atomiques}
  \vspace{-2mm}
  \begin{exampleblock}{Java}
  \begin{itemize}
    \item Dans le package \lstinline{java.util.concurrent.atomic}
  \begin{itemize}
    \item \lstinline{AtomicInteger}, \lstinline{AtomicLong}, \lstinline{AtomicReference<T>}, ...
  \end{itemize}
  \end{itemize}
  \end{exampleblock}
  \vspace{-2mm}
  \begin{exampleblock}{C++}
  \begin{itemize}
    \item Structure \lstinline{template <class T> struct std::atomic} 
    \item Fonctions de \lstinline{<atomic>}
  \end{itemize}
 \end{exampleblock}
  \begin{alertblock}{Méthodes \lstinline{get()} et \lstinline{set()} (Java) ou \lstinline{load()} et \lstinline{store()} (C++)}
  \begin{itemize}
    \item Lectures et écritures \structure{atomiques}
  \end{itemize}
  \end{alertblock}
  \begin{block}{Méthodes RMW (read-modify-write)}
    \begin{itemize}
    \item test-and-set, fetch-and-add, compare\_and\_swap...
    \item Opérations atomiques matérielles (instructions spéciales)
    \item Permettent la synchronisation non-bloquante
    \end{itemize}
  \end{block}
\end{frame}


\begin{frame}{Structures de données non-bloquante en Java}
  \begin{itemize}
  \item Compteur : \lstinline{java.util.concurrent.atomic.LongAdder}
    \begin{itemize}
    \item \lstinline{void add(long x)} : incrémente
    \item \lstinline{long sum()} : lit
    \item \alert{Attention : cohérence ?}
    \end{itemize}
  \item File : \lstinline{java.util.concurrent.ConcurrentLinkedQueue<E>} :
    \begin{itemize}
    \item \lstinline{void add(E e)} : ajoute en queue
    \item \lstinline{E peek()} : lit la tête
    \item \lstinline{E poll()} : lit et supprime la tête
    \end{itemize}
  \item Liste doublement chaînée : \lstinline{java.util.concurrent.ConcurrentLinkedDeque<E>}
    \begin{itemize}
    \item \lstinline{void addFirst(E e)}, \lstinline{E getFirst()}, \lstinline{E pollFirst()} : accède la tête
    \item \lstinline{void addLast(E e)}, \lstinline{E getLast()}, \lstinline{E pollLast()} : accède la queue
    \end{itemize}
  \item Table de hashage : \lstinline{java.util.concurrent.ConcurrentHashMap<K,V>}
    \begin{itemize}
    \item \lstinline{put(K key, V value)} : ajoute
    \item \lstinline{get(K key)} : lit
    \item \lstinline{remove(K key)} : supprime une clé
    \item \lstinline{putIfAbsent(K key, V value)} : ajoute ou retourne la valeur
    \end{itemize}
  \end{itemize}
  \begin{citing}
  \item Présentation de Scott sur les structures de données non-bloquantes
  \end{citing}
\end{frame}




\begin{frame}[fragile]{Un compteur non-bloquant}
\small
\begin{itemize}
\item Implémentation de \lstinline{AtomicInteger.getAndIncrement} dans l'\href{https://github.com/openjdk-mirror/jdk7u-jdk/blob/master/src/share/classes/java/util/concurrent/atomic/AtomicInteger.java}{OpenJDK 7}
\end{itemize}

\vspace{-3mm}
  \begin{tikzpicture}
    \fill[alertColor!20, rounded corners] (6.7,6.35) rectangle (7.8,6.65);
    \fill[structure!20, rounded corners] (11.4,6.35) rectangle (11.7,6.65);
    \fill[structure!20, rounded corners] (5.5,5.05) rectangle (7.55,5.35);
    \fill[structure!20, rounded corners] (5.15,4.35) rectangle (6.5,4.65);

    \fill[alertColor!20, rounded corners] (6,5.4) rectangle (7.7,5.7);
    \fill[alertColor!20, rounded corners] (4.3,4.7) rectangle (7.7,5);
    
    \draw (5,5.18) node{\begin{minipage}{5cm}\begin{lstlisting}
class Counter {
  private AtomicInteger value = new AtomicInteger(0); 
  public int getAndIncrement() {
    for (;;) {
      int current = value.get();
      int next = current + 1;
      if (value.compareAndSet(current, next))
        return current;
    }
  }
}
\end{lstlisting}\end{minipage}};

\draw (7,1.2) node{\begin{minipage}{\textwidth}
\begin{block}{L'opération \alert{atomique} compare\_and\_swap}
\vspace{-3mm}
    \begin{lstlisting}[numbers=none]
compareAndSet(T expect, T udpade) {
  if (get() == expect) {
    set(update);
    return true;
  }
  return false;
}
    \end{lstlisting}
  \end{block}
\end{minipage}};

\draw (9,.5) node{\begin{minipage}{\textwidth}
    \begin{description}
    \item [Java :] \lstinline{boolean compareAndSet(T expect, T update)}
    \item [C++ :] \lstinline{bool compare_exchange_strong (T& expected, T val)}
    \end{description}
\end{minipage}};

\draw<2>[exampleColor] (9,3.5) node{Sûreté ?~~~~Vivacité ?};


  \end{tikzpicture}
\end{frame}

\mode<all>


