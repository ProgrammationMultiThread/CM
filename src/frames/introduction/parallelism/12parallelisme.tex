\mode*

\begin{frame} {Approches pour la programmation parallèle}
    \begin{shadequote}{C.A.R Hoare}
    A primary aim of an operating system is to share a computer installation among many programs making unpredictable demands upon its resources.
    \end{shadequote}

    \vfill

    \begin{block}{Processus versus thread}
        \begin{itemize}
        \item \alert{Informatique} = traitement auto\alert{matique} de l'\alert{informat}ion
        \item Le système d'exploitation abstrait le \alert{processeur} et la \alert{mémoire}
            \begin{description}\footnotesize
            \item[Processus :] contexte d'exécution d'un programme (partage de mémoire)
            \item[Thread :] description d'une exécution séquentielle (partage du processeur)
            \end{description}
        \item Chaque processus contient un ou plusieurs threads
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame} {Approches pour la programmation parallèle}
    \begin{exampleblock}{Programmation multi-processus}
       \begin{itemize}
         \item Plusieurs processus, un thread par processus
         \item Communication par passage de messages
         \item Avantages : 
       \begin{description}
         \item [Robustesse :] les processus sont isolés les uns des autres par l'OS
         \item [Répartition :] on peut répartir les processus sur un réseau de machines (passage à l'échelle)
       \end{description}
       \end{itemize}
     \end{exampleblock}
        
    \vfill
    \begin{exampleblock}{Programmation multi-threads}
       \begin{itemize}
         \item Un seul processus, plusieurs threads au sein du même processus
         \item Communication par mémoire partagée
         \item Avantages : 
        \begin{description}
        \item [Efficacité :] données et références partagées (pas de copie) %communication et commutation de contexte en espace utilisateur.
        \item [Simplicité :] intégration presque transparente au sein des langages de programmation %(communication par référence et par valeur)
        \end{description}
       \end{itemize}
    \end{exampleblock}
\end{frame}

\begin{frame}{Intégration aux langages de programmation}
  
\vfill
  \begin{block}{Java}
        La JVM est une machine multi-thread. Le \texttt{GC} est un thread.

    \begin{description}
    \item[API historique] Définition de tâches, de threads et outils basiques pour la synchronisation
    \item[Depuis Java 5] La bibliothèque \href{https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html}{\lstinline{java.util.concurrent}}
    repose en grande partie sur les travaux de Doug Lea (\url{http://gee.cs.oswego.edu/dl/index.html})
    \end{description}
    \end{block}
\vfill
\begin{block}{C++}
    Donne accès aux threads du système.
    \begin{description}
    \item[Avant C++11] accès direct aux threads système (\structure{POSIX pthread} et \structure{WINAPI thread} depuis les années 1990).
    \item[Depuis C++11] intégration d'une API à la bibliothèque standard.
    \end{description}
    \end{block}
\vfill

\end{frame}


\begin{frame}[fragile]{Tâche}

  \begin{itemize}
  \item Code exécuté par un thread.
  \end{itemize}

  \begin{exampleblock}{C++}
    N'importe quelle fonction (pointeur de fonction)
    \begin{lstlisting}[numbers=none]
  void printer (string message) {
    cout << message << endl;
  }
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}{Java}
  Implémentation de l'interface fonctionnelle \lstinline{Runnable}
     \begin{lstlisting}[numbers=none]
  public record Printer (String message) implements Runnable {

    public void run () {
      System.out.println(message);
    }

  }
    \end{lstlisting}
\end{exampleblock}
\end{frame}


\begin{frame}[fragile]{Thread et contexte d'exécution}

  \begin{block}{Java : classe \lstinline{java.lang.Thread}}
     \begin{lstlisting}[numbers=none]
var task = new Printer("hello world");
//Runnable task = () -> System.out.println("hello world");
var thread = new Thread(task);
thread.start();
    \end{lstlisting}
    \end{block}

  \begin{block}{C++ : classe \lstinline{std::thread}}
    \begin{lstlisting}[numbers=none]
thread t(printer, "hello world");
// Started by constructor
   \end{lstlisting}
  \end{block}


  \begin{exampleblock}{Exemple}
    \begin{lstlisting}[numbers=none]
var messages = new String[]{"Hello", "Multithreaded", "World"};
for(var message : messages) {
  new Thread(()->System.out.print(message)).start();
}
   \end{lstlisting}
  \end{exampleblock}
\begin{citing}
\jitem \lstinline{cm1/HelloWorld.java}
\end{citing}
\end{frame}



\begin{frame}[fragile]
  \frametitle{Principales méthodes de la classe gérant les threads}

  \vfill
\begin{block}{Obtenir la référence sur le thread qui contrôle la tâche en cours}
   \structure{Java :} \lstinline|Thread.currentThread()| \hfill
   \structure{C++ :} \lstinline|std::this_thread|
\end{block}
\pause
  \vfill
  \vfill
\begin{block}{Endormir le thread \lstinline{t} pour \lstinline{ms} millisecondes}
   \structure{Java :} \lstinline|t.sleep(ms)| \hfill
   \structure{C++ :} \lstinline|t.sleep_for(std::chrono::milliseconds(ms))|
 \end{block}
  \vfill
  \vfill
\pause
\begin{block}{Attente de la terminaison d'un thread \lstinline{t}}
 \begin{description}
 \item[Java ou C++ :] \lstinline|t.join()|
  \item [\alert{ attention :}] en C++, un thread doit être détaché avant la terminaison du thread qui l'a lancé (\lstinline|t.detach()|). 
 \end{description}
\end{block}
  \vfill
\end{frame}

\begin{frame}[fragile]{Interrompre proprement un thread}

  \begin{alertblock}{Forcer un thread à s'arrêter}
  Impossible : \lstinline|public void stop()| est dépréciée !
  \end{alertblock}
  \vfill
  \begin{block}{Méthode \lstinline|public void interrupt()|}
    Demande la terminaison.
    \begin{itemize}
    \item Lève un drapeau booléen pour avertir le thread.
    \item La tâche peut (doit) vérifier régulièrement les demandes d'interruption
    \begin{itemize}
    \item \lstinline|public static boolean interrupted()| ou
    \item \lstinline|public boolean isInterrupted()|.
    \end{itemize}
  \item \lstinline|interrupted()| et \lstinline|isInterrupted()| rebaissent le drapeau.
  \item Si le thread est bloqué ou en attente,  \lstinline|InterruptedException| est lancée.
    \end{itemize}
  \end{block}
  \vfill
  \begin{exampleblock}{Pas d'équivalent en C++}
    Utiliser une variable booléenne comme drapeau.
  \end{exampleblock}
\end{frame}



\begin{frame}[fragile]{L'interface \texttt{ExecutorService}}

\begin{block}{Association tâche / contexte d'exécution}
  \texttt{java.util.concurrent} offre les outils pour construire \structure{simplement} des associations $n \leftrightarrow m$ avec différentes stratégies

  \begin{lstlisting}
public interface ExecutorService {
  void execute (Runnable task);
  Future<?> submit (Runnable task);
  Future<T> submit (Callable<T> task);
  List<Future<T>> invokeAll (Collection<Callable<T>> tasks)
    throws InterruptedException;
  T invokeAny (Collection<Callable<T>> tasks)
    throws InterruptedException, ExecutionException;
}
  \end{lstlisting}
\end{block}

  \begin{exampleblock}{Exemple}
  \begin{lstlisting}
var threadPool = Executors.newFixedThreadPool(5);
for(int i = 0; i < 50; ++i){
  threadPool.execute(() -> System.out.println(i));
}
  \end{lstlisting}
  \end{exampleblock}
  
\end{frame}


\begin{frame}[fragile]{Tâche retournant un résultat}

  \begin{block}{L'interface \lstinline{Callable}}
    Version générique d'une tâche qui retourne un résultat.

    \begin{lstlisting}[numbers=none]
public interface Callable<V> {
  V call() throws Exception;
}
    \end{lstlisting}
  \end{block}
  
  \bigskip

  \begin{block}{L'interface \lstinline{Future}}
    Version générique du résultat d'un calcul \textit{asynchrone}. 

    \begin{lstlisting}[numbers=none]
public interface Future<V> {
  boolean cancel( boolean evenIfRunning );
  V get() throws InterruptedException, ExecutionException;
  V get( long timeout, TimeUnit unit ) throws...;
  boolean isCancelled();
  boolean isDone();
}
    \end{lstlisting}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Implémentations de \texttt{ExecutorService}}
  \begin{block}{Classe \lstinline{java.util.concurrent.Executors}}
    \textit{Factory} qui permet d'instancier simplement
    des \lstinline{ExecutorService}, dont :
    \begin{itemize}
    \item \structure{\lstinline{ThreadPoolExecutor} :} implante différentes variantes basées sur le concept de \textit{pool} de \lstinline{Thread} : \textit{single}, \textit{fixed}, \textit{cached}
    \item \structure{\lstinline{ScheduledThreadPoolExecutor} :} stratégie permettant de préciser un délai lors de la soumission, à écouler entre la soumission et le début de l'exécution de la tâche
    \item \structure{\lstinline{ForkJoinPool} :} stratégie particulière pour exécuter des \lstinline{ForkJoinTask}, qui créent elles-mêmes des tâches
    \item \structure{\lstinline{VirtualThreadPerTaskExecutor} :} ``green threads'' gérés par le langage et non par le système
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Quelle stratégie est la plus efficace ?}
  \begin{block}{Ça dépend de l'application !} 
    \begin{itemize}
    \item Trop peu de threads et on n'exploite pas les capacités de calcul. 
    \item Trop de threads et on perd du temps à leur manipulation.
    \end{itemize}
  \end{block}
  
  \begin{block}{Ça dépend de la plate-forme !}
    \begin{itemize}
    \item Machine : nombre de c{\oe}urs, hiérarchie mémoire, etc.
    \item OS : politique d'ordonnancement des threads côté noyau.
    \item JVM : implémentation des stratégies, politique d'ordonnancement des threads côté utilisateur.
    \end{itemize}
  \end{block}
  
  \begin{center}
  \alert{Mesurer les performances !}
  \end{center}
\end{frame}





\mode<all>


